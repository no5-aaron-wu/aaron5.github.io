<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++之类与对象 [1]: 多态</title>
      <link href="/2021/11/11/cpp-class-1/"/>
      <url>/2021/11/11/cpp-class-1/</url>
      
        <content type="html"><![CDATA[<h1 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h1><ul><li>目的：不同对象在接收到相同消息时(操作/函数)做不同响应</li><li>现象：对应同样成员函数名称，执行不同函数体<h1 id="多态性的实现"><a href="#多态性的实现" class="headerlink" title="多态性的实现"></a>多态性的实现</h1></li><li>虚函数：使用<code>virtual</code>关键字声明成员函数</li><li>声明格式： <code>virtual 函数返回值 函数名称(参数列表);</code> (派生类重新实现时加不加virtual都行)</li><li>指向派生类的基类指针会调用对应派生类实现的虚函数</li><li>如果派生类不实现虚函数，则继承基类的虚函数实现</li><li>当类中有虚函数的时候，会维持一个虚表指针，虚表指针指向虚表中对应到该类的虚函数的函数入口地址(运行时确定)，这叫做函数的动态绑定（非虚函数是静态绑定）<ul><li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li><li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li><li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li><li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li><li>对象的动态类型可以更改，但是静态类型无法更改；</li><li>要想实现多态，必须使用动态绑定；</li><li>在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；</li><li>建议：绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36），因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*virtual*/</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C* pc = <span class="keyword">new</span> <span class="built_in">C</span>(); <span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">B* pb = <span class="keyword">new</span> <span class="built_in">B</span>(); <span class="comment">//pb的静态类型和动态类型也都是B*；</span></span><br><span class="line">A* pa = pc;      <span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span></span><br><span class="line">pa = pb;         <span class="comment">//pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">C *pnull = <span class="literal">NULL</span>; <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pa-&gt;<span class="built_in">func</span>();      <span class="comment">//A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span></span><br><span class="line">pc-&gt;<span class="built_in">func</span>();      <span class="comment">//C::func() pc的动、静态类型都是C*，因此调用C::func()；</span></span><br><span class="line">pnull-&gt;<span class="built_in">func</span>();   <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span></span><br></pre></td></tr></table></figure></li><li>如果注释掉类C中的func函数定义，其他不变，即<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pa-&gt;<span class="built_in">func</span>();      <span class="comment">//A::func() 理由同上；</span></span><br><span class="line">pc-&gt;<span class="built_in">func</span>();      <span class="comment">//A::func() pc在类C中找不到func的定义，因此到其基类中寻找；</span></span><br><span class="line">pnull-&gt;<span class="built_in">func</span>();   <span class="comment">//A::func() 原因也解释过了；</span></span><br></pre></td></tr></table></figure></li><li>如果为A中的void func()函数添加virtual特性，其他不变，即<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pa-&gt;<span class="built_in">func</span>();      <span class="comment">//B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；</span></span><br><span class="line">pc-&gt;<span class="built_in">func</span>();      <span class="comment">//C::func() pc的动、静态类型都是C*，因此也是先在C中查找；</span></span><br><span class="line">pnull-&gt;<span class="built_in">func</span>();   <span class="comment">//空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；</span></span><br></pre></td></tr></table></figure></li><li>建议：绝对不要重新定义一个继承而来的virtual函数的缺省参数值，因为缺省参数值都是静态绑定（为了执行效率），而virtual函数却是动态绑定。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;E::func()\t&quot;</span>&lt;&lt; i &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> :</span> <span class="keyword">public</span> E</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;F::func()\t&quot;</span> &lt;&lt; i &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F* pf = <span class="keyword">new</span> <span class="built_in">F</span>();</span><br><span class="line">    E* pe = pf;</span><br><span class="line">    pf-&gt;<span class="built_in">func</span>(); <span class="comment">//F::func() 1  正常，就该如此；</span></span><br><span class="line">    pe-&gt;<span class="built_in">func</span>(); <span class="comment">//F::func() 0  哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1></li></ul></li><li>充当占位函数，没有任何实现</li><li>派生类负责实现其具体功能</li><li>声明格式： <code>virtual 函数返回值 函数名称(参数列表) = 0;</code></li><li>纯虚函数的虚表指针是存在的，只不过该指针指向0地址<h1 id="抽象类（纯虚类）"><a href="#抽象类（纯虚类）" class="headerlink" title="抽象类（纯虚类）"></a>抽象类（纯虚类）</h1></li><li>带有纯虚函数的类</li><li>作为类继承层次的上层</li><li>不能构造抽象类的对象，但可以存在抽象类的指针或引用<h1 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h1></li><li>保持多态性需要虚析构函数，以保证能够正确释放对象</li><li>当一个类有子类时，该类的析构函数必须是虚函数，否则可能会有资源释放不完全的情况（因为非虚函数是静态绑定的）；<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">A</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;~A()!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">B</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;~B()!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">C</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;~C()!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A* pa1 = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">A* pa2 = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line"><span class="keyword">delete</span> pa1;</span><br><span class="line"><span class="keyword">delete</span> pa2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只会调用父类的析构函数，如果这时子类的析构函数中有关于内存释放的操作，将会造成内存泄露。</span></span><br><span class="line"><span class="comment">//~A()!</span></span><br><span class="line"><span class="comment">//~A()!</span></span><br></pre></td></tr></table></figure></li><li>需要给父类的析构函数加上virtual<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;~A()!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line"><span class="comment">//~B()!</span></span><br><span class="line"><span class="comment">//~A()!</span></span><br><span class="line"><span class="comment">//~C()!</span></span><br><span class="line"><span class="comment">//~A()!</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI算法基础 [1]：mIoU</title>
      <link href="/2021/11/11/AI-Algorithm-1-mIoU/"/>
      <url>/2021/11/11/AI-Algorithm-1-mIoU/</url>
      
        <content type="html"><![CDATA[<h1 id="1-IoU-Intersection-over-Union-交并比"><a href="#1-IoU-Intersection-over-Union-交并比" class="headerlink" title="1. IoU(Intersection over Union 交并比)"></a>1. IoU(Intersection over Union 交并比)</h1><ul><li>就是矩形框A、B的重叠面积占A、B并集的面积比例。<br><code>IoU=Area(A∩B)/Area(A∪B)</code><br><img src="1.png" alt="fig1"></li><li>预测的结果往往就是四种情况：<ul><li>true positive（TP） 真正 被判定为正样本，事实上也是正样本 </li><li>false positive（FP） 假正 被判定为正样本，但事实上是负样本 </li><li>true negative（TN） 真负 被判定为负样本，事实上也是负样本 </li><li>false negative（FN） 假负 被判定为负样本，但事实上是正样本<blockquote><p>第二个字母：What’s your judgement about the sample?<br>第一个字母：Is your judgement right(true) or not(false)?</p></blockquote></li></ul></li></ul><p><img src="2.png" alt="fig2"><br>基于以上定义：<code>IoU=TP/(FP+FN+TP)</code></p><h1 id="2-mIoU（Mean-Intersection-over-Union-均交并比"><a href="#2-mIoU（Mean-Intersection-over-Union-均交并比" class="headerlink" title="2. mIoU（Mean Intersection over Union 均交并比"></a>2. mIoU（Mean Intersection over Union 均交并比</h1><p>即对每个类别计算出的IoU求平均。<br><img src="3.png" alt="fig3"><br>其中，i表示真实值，j表示预测值，pij表示将i预测成j的数量，故上式等价于<br><img src="4.png" alt="fig4"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
