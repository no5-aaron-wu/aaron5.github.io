<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>EffectiveC++-5-ReadNote05 | 旭穹の陋室</title><meta name="keywords" content="C++"><meta name="author" content="旭穹"><meta name="copyright" content="旭穹"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 本文是阅读《Effective C++ 改善程序与设计的55个具体做法（第三版）》的心得笔记第五部分，文章也会按照原书的顺序依次记录各个条款。 第一部分的阅读笔记参见effective C++ 读书笔记01。 第二部分的阅读笔记参见effective C++ 读书笔记02。 第三部分的阅读笔记参见effective C++ 读书笔记03。 第四部分的阅读笔记参见effective C++ 读">
<meta property="og:type" content="article">
<meta property="og:title" content="EffectiveC++-5-ReadNote05">
<meta property="og:url" content="https://no5-aaron-wu.github.io/2022/08/31/EffectiveC-5-ReadNote05/index.html">
<meta property="og:site_name" content="旭穹の陋室">
<meta property="og:description" content="前言 本文是阅读《Effective C++ 改善程序与设计的55个具体做法（第三版）》的心得笔记第五部分，文章也会按照原书的顺序依次记录各个条款。 第一部分的阅读笔记参见effective C++ 读书笔记01。 第二部分的阅读笔记参见effective C++ 读书笔记02。 第三部分的阅读笔记参见effective C++ 读书笔记03。 第四部分的阅读笔记参见effective C++ 读">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://no5-aaron-wu.github.io/images/%E6%88%98%E5%8F%8CCG_%E8%AF%B4%E5%A3%B0%E5%86%8D%E8%A7%81.png">
<meta property="article:published_time" content="2022-08-31T11:12:16.000Z">
<meta property="article:modified_time" content="2022-09-25T05:54:55.141Z">
<meta property="article:author" content="旭穹">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://no5-aaron-wu.github.io/images/%E6%88%98%E5%8F%8CCG_%E8%AF%B4%E5%A3%B0%E5%86%8D%E8%A7%81.png"><link rel="shortcut icon" href="/images/ania_128x128.ico"><link rel="canonical" href="https://no5-aaron-wu.github.io/2022/08/31/EffectiveC-5-ReadNote05/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="zlQaq8XLp3Oj3DgDnpkA0mCzGbGvflp_U-vZVql_E-E"/><meta name="msvalidate.01" content="EAE2F4C7507064F526B5924DA5DCD005"/><meta name="baidu-site-verification" content="code-XsSJQ4q5sT"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-6DDC82R7DV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6DDC82R7DV');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#009f6a","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'EffectiveC++-5-ReadNote05',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-09-25 05:54:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><style>#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before { -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; }</style><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,300&display=swap" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/%E6%88%98%E5%8F%8CCG_%E8%AF%B4%E5%A3%B0%E5%86%8D%E8%A7%81.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">旭穹の陋室</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">EffectiveC++-5-ReadNote05</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-31T11:12:16.000Z" title="发表于 2022-08-31 11:12:16">2022-08-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-25T05:54:55.141Z" title="更新于 2022-09-25 05:54:55">2022-09-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="EffectiveC++-5-ReadNote05"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>前言</h1>
<p>本文是阅读《Effective C++ 改善程序与设计的55个具体做法（第三版）》的心得笔记第五部分，文章也会按照原书的顺序依次记录各个条款。</p>
<p>第一部分的阅读笔记参见<a href="https://no5-aaron-wu.github.io/2022/04/25/EffectiveC-1-ReadNote01/">effective C++ 读书笔记01</a>。</p>
<p>第二部分的阅读笔记参见<a href="https://no5-aaron-wu.github.io/2022/05/06/EffectiveC-2-ReadNote02/">effective C++ 读书笔记02</a>。</p>
<p>第三部分的阅读笔记参见<a href="https://no5-aaron-wu.github.io/2022/05/24/EffectiveC-3-ReadNote03/">effective C++ 读书笔记03</a>。</p>
<p>第四部分的阅读笔记参见<a href="https://no5-aaron-wu.github.io/2022/06/20/EffectiveC-4-ReadNote04/">effective C++ 读书笔记04</a>。</p>
<h1>继承与面向对象设计</h1>
<h2 id="条款32：确定你的public-继承塑模出-is-a-关系">条款32：确定你的public 继承塑模出 is-a 关系</h2>
<p>以 C++ 进行面向对象编程时，最重要的一条规则是：<strong>public inheritance（公开继承）意味着 <em>is-a</em>（是一种）的关系。<strong>也就是说，每一个公开继承的派生类对象同时也是一个基类对象，反之不成立，基类是更一般化的概念，派生类是更特殊化的概念。即</strong>里氏替换原则</strong>（Liskov Substitution Principle）：任何基类可以出现的地方，子类一定可以出现。比如下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>在上例中，我们可以认为，每个学生都是人，但并非每个人都是学生。人的概念比学生更一般化，学生是人的一种特殊形式。因此，在C++中，任何函数如果期望获得一个类型为Person（或Person指针或Person引用）的实参，也都愿意接受一个Student对象（或Student指针或Student引用）。但需要注意，这只在<strong>public继承的前提下</strong>才成立。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SOLID">设计模式五大原则</a>（SOLID）：</p>
<p>Single Responsibility Principle：单一职责原则</p>
<p>Open Closed Principle：开闭原则</p>
<p>Liskov Substitution Principle：里氏替换原则</p>
<p>Interface Segregation Principle：接口隔离原则</p>
<p>Dependence Inversion Principle：依赖倒置原则</p>
</blockquote>
<p>public 继承和 is-a 关系看似很好理解，但有时候会跟你的现实直觉相左。比如企鹅<strong>是一种</strong>鸟，但企鹅不会飞，那么我们就不能给<code>Bird</code>类声明<code>Fly</code>方法，因为并不是所有鸟都会飞。我们可以通过如下设计来解决：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> &#123;</span></span><br><span class="line">	...							<span class="comment">// 没有声明fly函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyingBird</span>:</span> <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span>:</span> <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    ...							<span class="comment">// 没有声明fly函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有另外一个场景，数学概念中我们认为正方形是一种矩形，所以想当然地在C++代码中做如下继承设计<code>class Square: public Rectangle</code>，但实际上适用于矩形的属性修改规则，并不适用于正方形。所以这种public继承关系并不正确。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> newHeight)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> newWidth)</span></span>;			<span class="comment">// 可以单独设置长和宽</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">width</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>:</span> <span class="keyword">public</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> newHeight)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> newWidth)</span> <span class="keyword">override</span></span>;	<span class="comment">// 长和宽要同时变</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeBigger</span><span class="params">(Rectangle&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldHeight = r.<span class="built_in">height</span>();</span><br><span class="line">    r.<span class="built_in">setWidth</span>(r.<span class="built_in">width</span>() + <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">assert</span>(r.<span class="built_in">height</span>() == oldHeight);				<span class="comment">// 对矩形成立，但对正方形不成立</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条款33：避免遮掩继承而来的名称">条款33：避免遮掩继承而来的名称</h2>
<p>所谓<strong>遮掩</strong>，是指对<strong>名称</strong>（变量名或函数名）的覆盖。最常见的就是，内层作用域的名称会遮掩外层作用域的名称。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;										<span class="comment">// global 变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">0.1</span>;								<span class="comment">// local 变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is &quot;</span> &lt;&lt; x &lt;&lt; std::endl;		<span class="comment">// x is 0.1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，遮掩的对象是名称。上例中<code>x</code>变量的类型是否相同，都不影响名称的遮掩。</p>
<p>现在考虑继承体系，则有<strong>派生类作用域的名称会遮掩基类作用域的名称</strong>，同样只与名称有关，与名称类型无关。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;		<span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;		<span class="comment">// 重载</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;			<span class="comment">// 重载</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;			<span class="comment">// 纯虚函数重写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;					<span class="comment">// </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户代码</span></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();		<span class="comment">// 没问题，调用Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);		<span class="comment">// 编译错误，Base::mf1被Derived::mf1遮掩</span></span><br><span class="line">d.<span class="built_in">mf2</span>();		<span class="comment">// 没问题，调用Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();		<span class="comment">// 没问题，调用Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(y);		<span class="comment">// 编译错误，Base::mf3被Derived::mf3遮掩</span></span><br></pre></td></tr></table></figure>
<p>在上例中，派生类中的<code>mf1</code>和<code>mf3</code>会遮掩基类中的所有同名函数，导致基类的重载不可用。</p>
<p>但是，一般情况下，我们是不希望遮掩发生的。因为我们使用了public继承，便希望<code>Derived</code> <strong>is-a</strong> <code>Base</code>，则<code>Base</code>能做的事，<code>Derived</code>也应该都能做。而遮掩违背了这样的原则，所以我们需要打破这种缺省的遮掩行为。方法有<strong>使用using声明式</strong>和<strong>使用转发函数</strong>。</p>
<h3 id="using声明式">using声明式</h3>
<p>使用using声明式可以让<code>Derived</code>忽略名称遮掩，看到<code>Base</code>作用域内的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">... 							<span class="comment">// 基类不变</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="keyword">using</span> Base::mf1;</span><br><span class="line">    <span class="keyword">using</span> Base::mf3;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;			<span class="comment">// 纯虚函数重写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;					<span class="comment">// </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户代码</span></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();		<span class="comment">// 没问题，调用Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);		<span class="comment">// 现在没问题，调用Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>();		<span class="comment">// 没问题，调用Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();		<span class="comment">// 没问题，调用Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(y);		<span class="comment">// 现在没问题，调用Base::mf3</span></span><br></pre></td></tr></table></figure>
<h3 id="转发函数（forward-function）">转发函数（forward function）</h3>
<p>在private继承中，强调继承实现而不是继承接口。因此，有时候我们只希望继承一部分函数实现，而不是所有函数。此时可以用<strong>转发函数</strong>实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">... 							<span class="comment">// 基类不变</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">private</span> Base &#123;	<span class="comment">// 注意是private继承</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>&#123;		<span class="comment">// 转发函数</span></span><br><span class="line">        Base::<span class="built_in">mf1</span>();			<span class="comment">// 调用基类的实现</span></span><br><span class="line">    &#125;			</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户代码</span></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();		<span class="comment">// 没问题，调用Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);		<span class="comment">// 编译错误，Base::mf1被Derived::mf1遮掩</span></span><br></pre></td></tr></table></figure>
<h2 id="条款34：区分接口继承和实现继承">条款34：区分接口继承和实现继承</h2>
<p>public继承下，成员函数继承由两部分组成：<strong>函数接口继承</strong>和<strong>函数实现继承</strong>。我们在设计类时，一定要清楚我们希望的，到底是继承接口还是继承实现，还是两个都要。那么有以下几点规则可供参考：</p>
<ul>
<li>
<p><strong>对于public继承，成员函数（无论是非虚函数，虚函数还是纯虚函数）的接口总是会被继承。</strong></p>
<p>public继承意味着 <strong>is-a</strong> 的关系，那么基类能做的事，派生类应当也都能做；</p>
</li>
<li>
<p><strong>声明纯虚函数的目的是为了让派生类只继承函数接口。</strong></p>
<p>对于纯虚函数，派生类<strong>必须</strong>重新实现该接口。需要注意的是，<em>C++不会禁止基类给出其纯虚函数的实现</em>，但是除非有必要的理由，我们一般不会这样做。</p>
</li>
<li>
<p><strong>派生类可以同时继承基类的（非纯）虚函数的接口和缺省实现。</strong></p>
<p>对于（非纯）虚函数，派生类可以选择<strong>重写</strong>其实现，也可以选择使用基类的缺省实现。但是这样选择上的自由，却可能带来隐患。比如派生类中确实是需要重写虚函数的实现，但是忘记了，此时就会使用缺省实现，编译器也不会给出任何提示。比如下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airport</span> &#123;</span> ... &#125;;		<span class="comment">// 机场类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">    ...						<span class="comment">// 缺省实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span> <span class="keyword">public</span> Airplane &#123; ... &#125;;	<span class="comment">// A类飞机	</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span>:</span> <span class="keyword">public</span> Airplane &#123; ... &#125;;	<span class="comment">// B类飞机 都可以使用缺省的fly方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span>:</span> <span class="keyword">public</span> Airplane &#123; ... &#125;;	<span class="comment">// C类飞机 也未重写fly 但飞行方式不同 有问题！！ </span></span><br></pre></td></tr></table></figure>
<p>想要规避该隐患，核心思想在于切断<strong>virtual函数接口</strong>和其<strong>缺省实现</strong>之间的联系。有如下两种方法可供选择：</p>
<ol>
<li>将<code>fly</code>函数改为纯虚函数，只提供飞行接口。飞行的缺省实现也会在<code>Airplane</code>中提供，但放在一个独立的非虚的<code>defaultFly</code>函数中。若派生类希望使用缺省实现，则可在<code>Fly</code>函数的重写中调用<code>defaultFly</code>，若不想，则可自定义<code>Fly</code>函数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airport</span> &#123;</span> ... &#125;;		<span class="comment">// 机场类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:					<span class="comment">// 与private相比，可以被派生类继承</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defaultFly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;	<span class="comment">// </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defaultFly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">    ...						<span class="comment">// 缺省实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">defaultFly</span>(destination);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span>:</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">defaultFly</span>(destination);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span>:</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">    ...						<span class="comment">// 重写实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>将<code>fly</code>函数改为纯虚函数，并在<code>Airplane</code>中给出其缺省实现。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airport</span> &#123;</span> ... &#125;;		<span class="comment">// 机场类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;	<span class="comment">// 纯虚函数的实现</span></span><br><span class="line">    ...						<span class="comment">// 缺省实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">        Airplane::<span class="built_in">fly</span>(destination);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span>:</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">        Airplane::<span class="built_in">fly</span>(destination);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span>:</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">    ...						<span class="comment">// 重写实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>声明非虚函数的目的是为了令派生类继承函数的接口和强制实现。</strong></p>
<p>如果成员函数是个非虚函数，则表明它并不打算在派生类中有不同的行为。即非虚成员函数的不变性高于其特异性。即非虚函数绝不应该在派生类中被重写。</p>
</li>
</ul>
<h2 id="条款35：考虑virtual函数以外的其他选择">条款35：考虑virtual函数以外的其他选择</h2>
<p>假设你正在写一个游戏软件，游戏中的人物会有健康值属性，不同的人物的健康值计算方式不同，那么你就可以做这样一个中规中矩的设计：基类给出一个public虚函数接口<code>healthValue</code>，并提供缺省实现，不同派生类可以重写该函数。那么，有没有其他替代方式呢？</p>
<h3 id="藉由-Non-Virtual-Interface（NVI）手法实现-Template-Method-模式">藉由 Non-Virtual Interface（NVI）手法实现 Template Method 模式</h3>
<p>有一个流派主张 <strong>virtual 函数应该几乎总是 private 的（也有例外，比如多态中的基类析构函数）</strong>。基于这种主张，可以让<code>healthValue</code>成为一个public non-virtual 函数，并调用一个private virtual的函数实现。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;			<span class="comment">// 不会被派生类重写</span></span><br><span class="line">        ...								<span class="comment">// 事前工作</span></span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="built_in">doHealthValue</span>();	<span class="comment">// 真正的工作</span></span><br><span class="line">        ...								<span class="comment">// 事后工作</span></span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;	<span class="comment">// 会被派生类重写</span></span><br><span class="line">        ...								<span class="comment">// 缺省实现，虽说是inline，但不是有意为之</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这一基本设计，<strong>令用户通过 public non-virtual 成员函数间接调用 private virtual 函数</strong>，称为NVI手法。也就是所谓的 <strong>Template Method</strong> 设计模式（与C++ Template 无关），这个 non-virtual 函数被称为 virtual函数的外覆器（wrapper）。</p>
<p>NVI手法的优点是可以给真正的工作提供一些必要的事前准备工作和事后清理工作：事前准备工作包括锁定互斥器（locking a mutex），制造运转日志记录项（log entry），验证类约束条件，验证函数先决条件等；事后清理工作包括互斥器解除锁定（unlocking a mutex），验证函数的的事后条件，再次验证类的约束条件等。</p>
<p>NVI手法也有一些反直觉的地方，即在派生类中重写了private virtual函数，但这些重写函数却不会被派生类调用。但其实这并不矛盾，重写virtual，赋予了派生类“如何实现机制”的控制能力，但基类保留了诉说“函数何时被调用”的权利。</p>
<h3 id="藉由-Function-Pointers（函数指针）实现-Strategy-模式">藉由 Function Pointers（函数指针）实现 Strategy 模式</h3>
<p>主要思想是增加一个函数指针作为private成员变量，该函数通过外部传入，从而实现不同的计算健康值的行为。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span>										<span class="comment">// 前置声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;				<span class="comment">// 计算健康值的缺省实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;	<span class="comment">// 函数指针定义</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种设计就是所谓的 Strategy 模式。它提供了如下两个有趣的设计弹性：</p>
<ul>
<li>
<p>同一人物的不同实体可以有不同的健康计算函数。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span>:</span> <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : GameCharacter(hcf) &#123;</span> ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;		<span class="comment">// 健康值计算函数1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthSlowly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;			<span class="comment">// 健康值计算函数2</span></span><br><span class="line"></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>;</span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthSlowly)</span></span>;		<span class="comment">// 相同的人物类型搭配不同的健康值计算方式</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>某已知人物之健康值计算函数可以在运行期变更。只需给<code>GameCharacter</code>提供一个<code>setHealthCalculator</code>函数，用来替换当前的健康值计算函数指针。</p>
</li>
</ul>
<p>这种设计意味着将健康值计算函数独立于<code>GameCharacter</code>继承体系之外，成为一个non-member non-friend 函数，则健康值计算函数将无权访问类的non-public部分，若健康值计算需要这些non-public信息，则需要<strong>弱化class的封装</strong>：将健康值计算函数声明为友元函数，为该函数提供所需信息的pubic访问函数。因此，这种设计的优点（两个弹性）能否弥补其缺点（可能的封装性弱化），则需要根据实际情况进行斟酌。</p>
<h3 id="藉由std-function完成-Strategy-模式">藉由<code>std::function</code>完成 Strategy 模式</h3>
<p>将上述的函数指针的成员变量替换为<code>std::function</code>对象，<code>std::function</code>对象可以持有任何可调用物（函数指针，函数对象或成员函数指针），相当于一个<strong>更加泛化的函数指针</strong>，从而使得设计更具弹性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span>										<span class="comment">// 前置声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;				<span class="comment">// 计算健康值的缺省实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::function&lt;<span class="built_in"><span class="keyword">int</span></span> (<span class="keyword">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;	<span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里，由<code>std::function</code>类型（即我们typedef的<code>HealthCalcFunc</code>类型）产生的对象可以持有任何与签名式（<code>int (const GameCharacter&amp;)</code>）兼容的可调用物，所谓兼容，即为可调用物的参数可以被隐式转换为<code>const GameCharacter&amp;</code>，而其返回类型可被隐式转换为<code>int</code>。可以传入的可调用物示例如下：</p>
<ol>
<li>
<p>函数指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">calcHealth</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;	<span class="comment">// 返回值不是int，但可以隐式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户代码</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(calcHealth)</span></span>;			<span class="comment">// EvilBadGuy的声明如前</span></span><br><span class="line">ebg1.<span class="built_in">healthValue</span>();						<span class="comment">// </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数对象（仿函数）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HealthCalculator</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span> </span>&#123;	<span class="comment">// 重载operator()</span></span><br><span class="line">        ... 											<span class="comment">// 省略实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户代码</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(HealthCalculator())</span></span>;	</span><br><span class="line">ebg2.<span class="built_in">healthValue</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>成员函数指针（std::bind）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameLevel</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">health</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span></span>;		<span class="comment">// 成员函数，返回值不是int</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line">...</span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg3</span><span class="params">(std::bind(&amp;GameLevel::health, currentLevel,		<span class="comment">// 传入对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          std::placeholders::_1))</span></span>;	</span><br><span class="line"></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg4</span><span class="params">(std::bind(&amp;GameLevel::health, &amp;currentLevel, 	<span class="comment">// 传入对象指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          std::placeholders::_1))</span></span>;	</span><br><span class="line"></span><br><span class="line">ebg3.<span class="built_in">healthValue</span>();	<span class="comment">// 调用时会先构造一个currentLevel的临时对象，再调用临时对象的health函数</span></span><br><span class="line">ebg4.<span class="built_in">healthValue</span>();	<span class="comment">// 调用时会直接调用currentLevel对象的health函数</span></span><br></pre></td></tr></table></figure>
<p>其中<code>std::bind</code>是一个绑定器，函数原型为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Fn</span>, <span class="type">class... Args&gt;</span></span></span><br><span class="line">  <span class="comment">/* unspecified */</span> bind (Fn&amp;&amp; fn, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure>
<p>可以将传入的可调用对象（第一个参数<code>fn</code>）与其对应参数（用逗号分割的参数列表<code>args</code>）进行绑定，返回一个新的可调用对象。参数列表<code>args</code>中：</p>
<ul>
<li>若为一个具体的值，则返回的可调用对象将始终使用该值作为参数；</li>
<li>若为一个形如<code>_n</code>的占位符（从_1开始，随使用占位符的数量递增），则返回的可调用对象会转发传递给可调用对象的参数；</li>
</ul>
<p>在上例中，使用<code>std::bind</code>来绑定<code>GameLevel</code>类的成员函数<code>health</code>，因为成员函数还有一个隐式参数，即<code>this</code>指针。而<code>HealthCalcFunc</code>的签名式只兼容单一参数<code>GameCharacter</code>，所以需要使用<code>std::bind</code>来固定其中的隐式参数。需要注意的是，给<code>this</code>传入对象或者对象指针都是可以的，但调用函数的对象会有区别（见代码注释），这在被调用函数会修改调用对象的成员变量时尤其需要注意。</p>
</li>
<li>
<p>匿名函数（lambda表达式）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">EvilBadGuy <span class="title">ebg5</span><span class="params">([&amp;](<span class="keyword">const</span> GameCharacter&amp; gc) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    ...		<span class="comment">// 省略实现</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">ebg5.<span class="built_in">healthValue</span>();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="古典的-Strategy-模式">古典的 Strategy 模式</h3>
<p>传统的 Strategy 模式做法会将健康值计算函数做成一个分离的继承体系中的virtual成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span>			<span class="comment">// 前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCalcFunc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlowHealthLoser</span>:</span> <span class="keyword">public</span> HealthCalcFunc &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SlowHealthLoser::calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf = &amp;defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : pHealthCalc(phcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHealthCalc-&gt;<span class="built_in">calc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc* pHealthCalc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SlowHealthLoser shl;</span><br><span class="line"><span class="function">GameCharacter <span class="title">gc1</span><span class="params">(&amp;shl)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="条款36：绝不重新定义继承而来的-non-virtual-函数">条款36：绝不重新定义继承而来的 non-virtual 函数</h2>
<p>条款32中指出，public继承意味着 **is-a（是一种）**的关系。</p>
<p>条款33中指出，<strong>派生类作用域的名称会遮掩基类作用域的名称</strong>。</p>
<p>条款34中指出，<strong>声明非虚函数的目的是为了令派生类继承函数的接口和强制实现。</strong></p>
<p>这一切都导向同一个结论，<strong>任何情况下都不应该重新定义一个继承而来的non-virtual函数</strong>。</p>
<p>条款7中也指出，<strong>多态基类（会被继承）的析构函数应当是virtual的</strong>。否则也会违反本条款。</p>
<p>可以看下面这个反例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B::mf()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf</span><span class="params">()</span> </span>&#123;			<span class="comment">// 遮掩了基类的名称</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;D::mf()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户代码</span></span><br><span class="line">D d;</span><br><span class="line">D* pD = &amp;d;</span><br><span class="line">B* pB = &amp;d;</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">mf</span>();			<span class="comment">// 输出 D::mf()，没问题</span></span><br><span class="line">pB-&gt;<span class="built_in">mf</span>();		<span class="comment">// 输出 B::mf()，有问题！！！</span></span><br><span class="line">pD-&gt;<span class="built_in">mf</span>();		<span class="comment">// 输出 D::mf()，没问题</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上例中，我们预期的是函数调用是与具体对象绑定的，而不是与对象指针绑定的（即期望是动态绑定）。但是由于non-virtual函数是静态绑定的，这意味着，由于<code>pB</code>是一个基类指针，则通过<code>pB</code>调用的non-virtual函数永远都是<code>B</code>类所定义的版本，即使<code>pB</code>指向派生类对象<code>d</code>。</p>
<h2 id="条款37：绝不重新定义继承而来的缺省参数值">条款37：绝不重新定义继承而来的缺省参数值</h2>
<p>由于条款36指出，重新定义一个继承而来的non-virtual函数永远都错误的，所以我们将讨论范围缩小到”继承一个带有缺省参数值的virtual函数“。在此前提下，本条款成立的理由就是：<strong>virtual函数是动态绑定的，而缺省参数值是静态绑定的</strong>。考虑如下例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">ShapeColor</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    Red = <span class="number">0</span>,</span><br><span class="line"> 	Green,</span><br><span class="line"> 	Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = ShapeColor::Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类重新定义了缺省参数值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = ShapeColor::Green)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类移除了缺省参数值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户代码</span></span><br><span class="line">Shape* ps;					<span class="comment">// 静态类型为Shape*，无动态类型</span></span><br><span class="line">Shape* pc = <span class="keyword">new</span> Circle;		<span class="comment">// 静态类型为Shape*，动态类型为Circle*</span></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;	<span class="comment">// 静态类型为Shape*，动态类型为Rectangle*</span></span><br></pre></td></tr></table></figure>
<p>对象的静态类型（static type）即其被声明时所采用的类型。上述例子中<code>ps</code>，<code>pc</code>和<code>pr</code>都被声明为<code>Shape</code>指针类型，故它们的静态类型都为<code>Shape*</code>。</p>
<p>对象的动态类型（dynamic type）即其目前所指向的对象的类型。动态类型可以在程序执行过程中改变。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ps = pc;	<span class="comment">// ps的动态类型现在为Circle*</span></span><br><span class="line">ps = pr;	<span class="comment">// ps的动态类型现在为Rectangle*</span></span><br></pre></td></tr></table></figure>
<p>由于<strong>virtual函数是动态绑定的</strong>，即究竟调用virtual函数的哪一种实现，取决于调用对象的动态类型。所以有如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pc-&gt;<span class="built_in">draw</span>(ShapeColor::Red);		<span class="comment">// 调用Circle::draw(ShapeColor::Red)</span></span><br><span class="line">pr-&gt;<span class="built_in">draw</span>(ShapeColor::Red);		<span class="comment">// 调用Rectangle::draw(ShapeColor::Red)</span></span><br></pre></td></tr></table></figure>
<p>但是<strong>缺省函数值是静态绑定的</strong>，即使用哪一种实现的缺省函数值，取决于调用对象的静态类型。所有有如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pr-&gt;<span class="built_in">draw</span>();		<span class="comment">// 调用Rectangle::draw(ShapeColor::Red)</span></span><br></pre></td></tr></table></figure>
<p>在上述调用中，出现了基类和派生类的<code>draw</code>函数声明式各出一半力的怪异现象，这不是我们所期望的。而C++之所以没有将缺省参数值也设计成动态绑定，主要是为了运行期效率而做出的取舍。该问题不仅局限于对象指针，将指针换成引用，该问题依然存在。</p>
<p>但是，如果你严格遵守本条款，给基类和派生类同时提供相同的缺省参数值，也不是一个好的选择。因为这会导致代码重复，如果基类的缺省参数值，所有重复给定缺省参数值的派生类都得做相应的修改，否则就会再次违背本条款。那么怎么做才好呢？答案是使用条款35中提到NVI（non-virtual interface）手法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">ShapeColor</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    Red = <span class="number">0</span>,</span><br><span class="line"> 	Green,</span><br><span class="line"> 	Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = ShapeColor::Red)</span> <span class="keyword">const</span> </span>&#123;	<span class="comment">// non-virtual，不可重新定义</span></span><br><span class="line">        <span class="built_in">doDraw</span>();	<span class="comment">// 调用一个virtual</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;	<span class="comment">// 可被重新定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>;		<span class="comment">// 注意，不须指定缺省参数值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="条款38：通过复合塑模出-has-a-或“根据某物实现出”">条款38：通过复合塑模出 has-a 或“根据某物实现出”</h2>
<p>复合（composition）是一种常见的类关系，当某种类型的对象内含有其他类型的对象时，便是这种关系。</p>
<p>复合关系有两种意义：</p>
<ul>
<li>
<p>has-a（有一个） 关系：</p>
<p>对象属于应用域（application domain），即对象相当于塑造现实世界中的某些事物。例如<code>Person</code>类有<code>Address</code>、<code>PhoneNumber</code>等类型的成员变量。</p>
</li>
<li>
<p>is-implemented-in-terms-of（根据某物实现出）关系：</p>
<p>对象属于实现域（implementation domain），即其他对象纯粹是实现细节的人工设计。例如缓冲区（Buffers）、互斥器（Mutexes）等。</p>
<p>比如我们想通过<code>std::list</code>实现自定义的<code>Set</code>模板类（<code>std::set</code>是通过平衡查找树实现，效率更高，但空间开销也更大，假设这里我们的环境是空间比速度更重要），我们也许会这么做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span>:</span> <span class="keyword">public</span> std::list&lt;T&gt; &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>这是不对的，因为public继承意味着 <strong>is-a</strong> 关系，但是<code>std::list</code>允许存在重复元素，但是<code>Set</code>不行。正确的实现方式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">member</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function">std::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;T&gt; rep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Set&lt;T&gt;::<span class="built_in">member</span>(<span class="keyword">const</span> T&amp; item) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>(), rep.<span class="built_in">end</span>(), item) != rep.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Set&lt;T&gt;::<span class="built_in">insert</span>(<span class="keyword">const</span> T&amp; item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">member</span>(item)) rep.<span class="built_in">push_back</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Set&lt;T&gt;::<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; item) &#123;</span><br><span class="line">    <span class="keyword">typename</span> std::list&lt;T&gt;::iterator it = 	<span class="comment">// 关于typename的讨论见条款42</span></span><br><span class="line">        std::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>(), rep.<span class="built_in">end</span>(), item);</span><br><span class="line">    <span class="keyword">if</span> (it != rep.<span class="built_in">end</span>()) rep.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="keyword">size_t</span> Set&lt;T&gt;::<span class="built_in">size</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rep.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="条款39：明智而审慎地使用-private-继承">条款39：明智而审慎地使用 private 继承</h2>
<p>首先需要明确的是private继承的两个规则：</p>
<ol>
<li>如果类之间的继承关系是private，则编译器不会自动地将一个派生类对象隐式转换成一个基类对象；</li>
<li>由private继承而来的所有成员，在派生类中都会变成private属性；</li>
</ol>
<p>private继承意味着<strong>根据某物实现出（implemented-in-terms-of）</strong>,只是一种实现技术，是为了让派生类继承基类中已经准备好的一些实现，而不是因为派生类和基类存在任何客观上的关联关系。换句话说，私有继承只有实现部分被继承，而接口部分被略去，这也解释了上述规则2成立的原因。</p>
<p>但是，由条款38可知，复合的意义也是<strong>根据某物实现出（implemented-in-terms-of）</strong>，我们已经如何在private继承和复合之间做出抉择呢？答案是<strong>尽可能使用复合，必要时才使用private继承</strong>。看下面这个例子：</p>
<p>我们希望通过一个已有的计时类<code>Timer</code>来统计<code>Widget</code>类的性能情况，比如某个成员函数的调用频率等。用private继承和复合的实现分别如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="keyword">int</span> tickFrequency)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;	<span class="comment">// 定时器每滴答一次，此函数被自动调用一次</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现1：private继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>:</span> <span class="keyword">private</span> Timer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;	<span class="comment">// 重写，实现性能监控的目标功能</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现2：public继承 + 复合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WidgetTimer</span>:</span> <span class="keyword">public</span> Timer &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>public继承 + 复合相比于private继承的好处在于：</p>
<ol>
<li>可以阻止<code>Widget</code>的派生类再次重写onTick函数；</li>
<li>若将<code>WidgetTimer</code>类的实现移到<code>Widget</code>之外，并且<code>Widget</code>中持有指针指向一个<code>WidgetTimer</code>对象，则<code>Widget</code>类的声明可以只带一个<code>WidgetTimer</code>声明式，而不需要<code>#include Timer.h</code>，从而实现解耦，降低编译依赖。</li>
</ol>
<p>然而还有一种激进的情况会促使你选择private继承而非复合，那就是<strong>空白基类最优化</strong>（EBO，Empty Base Optimization）。所谓的<strong>空类</strong>（Empty Class）不带任何数据，即没有non-static成员变量，没有virtual函数，也没有virtual基类（但可以有typedefs，enums，static成员变量或non-virtual函数）。理论上，空类对象的大小应当为零，但由于技术理由，C++规定<strong>独立</strong>对象都必须有非零大小，所以C++会默默安插一个char（1字节）到空对象中。若该空类对象在其他类或结构体中，还要考虑内存对齐，则空类对象占用的空间将不止一个字节。而派生类对象中的基类成分不是独立的，不受上述规定的约束。故当对空间敏感时，可以通过private继承空类（的若干实现），来达到节约空间的目的，这便是空白基类最优化。此外，<strong>EBO只适用于单继承</strong>。一个例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span>* pChar;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(pChar str)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">color</span> &#123;</span></span><br><span class="line">        red, green, blue</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">privateFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Empty::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldIntsAndEmpty</span> &#123;</span>        <span class="comment">// 内存对齐后类大小为12字节</span></span><br><span class="line">    <span class="keyword">int</span> x_;     <span class="comment">// 4字节</span></span><br><span class="line">    <span class="keyword">int</span> y_;     <span class="comment">// 4字节</span></span><br><span class="line">    Empty e_;   <span class="comment">// 1字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldInts</span>:</span><span class="keyword">private</span> Empty &#123;  <span class="comment">// EBO，大小为8字节</span></span><br><span class="line">    <span class="keyword">int</span> x_;</span><br><span class="line">    <span class="keyword">int</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(HoldIntsAndEmpty) &lt;&lt; std::endl;     <span class="comment">// 12</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(HoldInts) &lt;&lt; std::endl;             <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条款40：明智而审慎地使用多重继承">条款40：明智而审慎地使用多重继承</h2>
<p>多重继承（MI，Multiple Inheritance）是指派生类继承多个基类。在使用多重继承时，就要考虑如下几个问题：</p>
<ul>
<li>从不同基类继承相同名称函数（或typedefs）时，会导致歧义问题，需要指定基类。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B1, <span class="keyword">public</span> B2 &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.<span class="built_in">foo</span>();			<span class="comment">// 编译报错，无法判断要调用哪个foo</span></span><br><span class="line">  	d.B1::<span class="built_in">foo</span>();	<span class="comment">// 指定B1</span></span><br><span class="line">    d.B2::<span class="built_in">foo</span>();	<span class="comment">// 指定B2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当派生类继承的多个基类有更高层的共同的基类时，就形成了<strong>钻石型多重继承</strong>。这时来自共同基类的成员变量经由不同的继承路径都会产生一笔备份，若我们不希望产生这样的重复，则需要用到<strong>虚继承</strong>。但是虚继承是有代价的，为了保证虚继承的正确性（避免成员变量重复），编译器需要在背后付出更多代价，这会导致虚继承派生类<strong>占用空间更大</strong>或<strong>运行速度更慢</strong>。此外，虚继承时virtual base classes（无论直接还是间接）的初始化责任由继承体系中最低层的类负责。所以：
<ul>
<li>非必要不使用虚继承；</li>
<li>若必须使用virtual base classes，则尽可能不在其中包含数据成员，从而不必担心初始化问题。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>:</span><span class="keyword">public</span> BB &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span>:</span><span class="keyword">public</span> BB &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VB1</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> BB &#123;	<span class="comment">// 虚继承</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VB2</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> BB &#123;	<span class="comment">// 虚继承</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B1, <span class="keyword">public</span> B2 &#123;		<span class="comment">// 会从两条继承路径中各继承一份a_</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VD</span>:</span><span class="keyword">public</span> VB1, <span class="keyword">public</span> VB2 &#123;	<span class="comment">// 只有一份a_</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">		d.a_ = <span class="number">1</span>;				<span class="comment">// 编译报错，无法判断使用哪个备份</span></span><br><span class="line">    d.B1::a_ = <span class="number">1</span>;</span><br><span class="line">    d.B2::a_ = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    VD vd;</span><br><span class="line">    vd.a_ = <span class="number">3</span>;			<span class="comment">// 编译通过，只有一个</span></span><br><span class="line">    vd.B1::a_ = <span class="number">3</span>;</span><br><span class="line">    vd.B2::a_ = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; d.B1::a_ &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; d.B2::a_ &lt;&lt; std::endl;										<span class="comment">// 1,2</span></span><br><span class="line">  	std::cout &lt;&lt; vd.a_ &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vd.B1::a_ &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vd.B2::a_ &lt;&lt; std::endl;	<span class="comment">// 4,4,4</span></span><br><span class="line">	  std::cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(d) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(vd) &lt;&lt; std::endl;									<span class="comment">// 8,24</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然能用单一继承就不要使用多重继承，但多重继承也并非完全是洪水猛兽，一个合理使用多重继承的例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPerson</span> &#123;</span>                                 <span class="comment">// 抽象类，无法实例化</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IPerson</span>() &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonInfo</span> &#123;</span>                              <span class="comment">// 既有的数据库类，可获取个人信息</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PersonInfo</span><span class="params">(<span class="keyword">int</span> pid)</span>:id_(pid) &#123;</span>&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PersonInfo</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">theName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> value[<span class="number">1024</span>];                <span class="comment">// 预留缓冲区给返回值，static会被自动初始化为0</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* testName = <span class="string">&quot;Aaron&quot;</span>;  <span class="comment">// 获取名字方法略去，以固定字符串代替</span></span><br><span class="line">        std::<span class="built_in">strcpy</span>(value, <span class="built_in">valueDelimOpen</span>());   <span class="comment">// 写入起始符号</span></span><br><span class="line">        std::<span class="built_in">strcat</span>(value, testName);           <span class="comment">// 写入名字</span></span><br><span class="line">        std::<span class="built_in">strcat</span>(value, <span class="built_in">valueDelimClose</span>());  <span class="comment">// 写入结束符号</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">theBirthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1993-01-01&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimClose</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> id_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的具体实现RealPerson</span></span><br><span class="line"><span class="comment">// 可以利用既有的PersonInfo类来实现name和birthDate，即根据某物实现出的关系，可以选择复合和private继承</span></span><br><span class="line"><span class="comment">// 但输出人名时不需要起始符号和结尾符号，所以需要重写valueDelimOpen和valueDelimClose</span></span><br><span class="line"><span class="comment">// 故选择private继承而不是复合，这样就得使用多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span>:</span> <span class="keyword">public</span> IPerson, <span class="keyword">private</span> PersonInfo &#123;  <span class="comment">// 多重继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RealPerson</span><span class="params">(<span class="keyword">int</span> pid)</span>: PersonInfo(pid) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;         <span class="comment">// 纯虚函数实现</span></span><br><span class="line">        <span class="keyword">return</span> PersonInfo::<span class="built_in">theName</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;    <span class="comment">// 纯虚函数实现</span></span><br><span class="line">        <span class="keyword">return</span> PersonInfo::<span class="built_in">theBirthDate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;       <span class="comment">// 重写界定符号函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimClose</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;      <span class="comment">// 重写界定符号函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">RealPerson <span class="title">rp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; rp.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rp.<span class="built_in">birthDate</span>() &lt;&lt; std::endl;   <span class="comment">// Aaron,1993-01-01</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">旭穹</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://no5-aaron-wu.github.io/2022/08/31/EffectiveC-5-ReadNote05/">https://no5-aaron-wu.github.io/2022/08/31/EffectiveC-5-ReadNote05/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://no5-aaron-wu.github.io" target="_blank">旭穹の陋室</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/images/%E6%88%98%E5%8F%8CCG_%E8%AF%B4%E5%A3%B0%E5%86%8D%E8%A7%81.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="/images/wechatpay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/07/14/cpp-modern-3-RValueReference/"><img class="next-cover" src="/images/pretty_derby_03.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">现代C++ [3]: 右值引用、移动语义和完美转发</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/14/cpp-modern-3-RValueReference/" title="现代C++ [3]: 右值引用、移动语义和完美转发"><img class="cover" src="/images/pretty_derby_03.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-14</div><div class="title">现代C++ [3]: 右值引用、移动语义和完美转发</div></div></a></div><div><a href="/2022/06/20/EffectiveC-4-ReadNote04/" title="Effective C++ 读书笔记04"><img class="cover" src="/images/zshz_01.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-20</div><div class="title">Effective C++ 读书笔记04</div></div></a></div><div><a href="/2022/06/01/cpp-modern-2-templateSpecialization/" title="现代C++ [2]: 模板特化"><img class="cover" src="/images/spyXfamily_03.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-01</div><div class="title">现代C++ [2]: 模板特化</div></div></a></div><div><a href="/2022/05/24/EffectiveC-3-ReadNote03/" title="Effective C++ 读书笔记03"><img class="cover" src="/images/spyXfamily_02.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-24</div><div class="title">Effective C++ 读书笔记03</div></div></a></div><div><a href="/2022/05/06/cpp-modern-1-SmartPointers/" title="现代C++ [1]: 智能指针"><img class="cover" src="/images/spyXfamily_01.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-06</div><div class="title">现代C++ [1]: 智能指针</div></div></a></div><div><a href="/2022/05/06/EffectiveC-2-ReadNote02/" title="Effective C++ 读书笔记02"><img class="cover" src="/images/comic01.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-06</div><div class="title">Effective C++ 读书笔记02</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">旭穹</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/no5-aaron-wu"><i class="fab fa-github"></i><span>我的github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:no5aaron@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">继承与面向对象设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE32%EF%BC%9A%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public-%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BA-is-a-%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.</span> <span class="toc-text">条款32：确定你的public 继承塑模出 is-a 关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE33%EF%BC%9A%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">2.2.</span> <span class="toc-text">条款33：避免遮掩继承而来的名称</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#using%E5%A3%B0%E6%98%8E%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">using声明式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91%E5%87%BD%E6%95%B0%EF%BC%88forward-function%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">转发函数（forward function）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE34%EF%BC%9A%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">2.3.</span> <span class="toc-text">条款34：区分接口继承和实现继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE35%EF%BC%9A%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="toc-number">2.4.</span> <span class="toc-text">条款35：考虑virtual函数以外的其他选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%97%89%E7%94%B1-Non-Virtual-Interface%EF%BC%88NVI%EF%BC%89%E6%89%8B%E6%B3%95%E5%AE%9E%E7%8E%B0-Template-Method-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">藉由 Non-Virtual Interface（NVI）手法实现 Template Method 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%97%89%E7%94%B1-Function-Pointers%EF%BC%88%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%89%E5%AE%9E%E7%8E%B0-Strategy-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">藉由 Function Pointers（函数指针）实现 Strategy 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%97%89%E7%94%B1std-function%E5%AE%8C%E6%88%90-Strategy-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.3.</span> <span class="toc-text">藉由std::function完成 Strategy 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A4%E5%85%B8%E7%9A%84-Strategy-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.4.</span> <span class="toc-text">古典的 Strategy 模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE36%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84-non-virtual-%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">条款36：绝不重新定义继承而来的 non-virtual 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE37%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">2.6.</span> <span class="toc-text">条款37：绝不重新定义继承而来的缺省参数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE38%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BA-has-a-%E6%88%96%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D"><span class="toc-number">2.7.</span> <span class="toc-text">条款38：通过复合塑模出 has-a 或“根据某物实现出”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE39%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8-private-%E7%BB%A7%E6%89%BF"><span class="toc-number">2.8.</span> <span class="toc-text">条款39：明智而审慎地使用 private 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE40%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">2.9.</span> <span class="toc-text">条款40：明智而审慎地使用多重继承</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/31/EffectiveC-5-ReadNote05/" title="EffectiveC++-5-ReadNote05"><img src="/images/%E6%88%98%E5%8F%8CCG_%E8%AF%B4%E5%A3%B0%E5%86%8D%E8%A7%81.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EffectiveC++-5-ReadNote05"/></a><div class="content"><a class="title" href="/2022/08/31/EffectiveC-5-ReadNote05/" title="EffectiveC++-5-ReadNote05">EffectiveC++-5-ReadNote05</a><time datetime="2022-08-31T11:12:16.000Z" title="发表于 2022-08-31 11:12:16">2022-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/14/cpp-modern-3-RValueReference/" title="现代C++ [3]: 右值引用、移动语义和完美转发"><img src="/images/pretty_derby_03.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="现代C++ [3]: 右值引用、移动语义和完美转发"/></a><div class="content"><a class="title" href="/2022/07/14/cpp-modern-3-RValueReference/" title="现代C++ [3]: 右值引用、移动语义和完美转发">现代C++ [3]: 右值引用、移动语义和完美转发</a><time datetime="2022-07-14T16:39:24.000Z" title="发表于 2022-07-14 16:39:24">2022-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/13/NLS-1-GetStart/" title="非线性最小二乘 [1]: GetStart"><img src="/images/pretty_derby_02.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="非线性最小二乘 [1]: GetStart"/></a><div class="content"><a class="title" href="/2022/07/13/NLS-1-GetStart/" title="非线性最小二乘 [1]: GetStart">非线性最小二乘 [1]: GetStart</a><time datetime="2022-07-13T14:45:59.000Z" title="发表于 2022-07-13 14:45:59">2022-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/08/EIGEN-1-GetStart/" title="Eigen[1]: GetStart"><img src="/images/pretty_derby_01.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Eigen[1]: GetStart"/></a><div class="content"><a class="title" href="/2022/07/08/EIGEN-1-GetStart/" title="Eigen[1]: GetStart">Eigen[1]: GetStart</a><time datetime="2022-07-08T11:11:20.000Z" title="发表于 2022-07-08 11:11:20">2022-07-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/20/EffectiveC-4-ReadNote04/" title="Effective C++ 读书笔记04"><img src="/images/zshz_01.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective C++ 读书笔记04"/></a><div class="content"><a class="title" href="/2022/06/20/EffectiveC-4-ReadNote04/" title="Effective C++ 读书笔记04">Effective C++ 读书笔记04</a><time datetime="2022-06-20T18:42:43.000Z" title="发表于 2022-06-20 18:42:43">2022-06-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/%E6%88%98%E5%8F%8CCG_%E8%AF%B4%E5%A3%B0%E5%86%8D%E8%A7%81.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 旭穹</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">谢临<a href="https://no5-aaron-wu.github.io/">陋室</a>, 欢迎留言！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 3000);</script></div><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '8238e4a92ed02fb5dcb8',
      clientSecret: '9c0dfb8fd7077aa7549fbda345a3b0c2cb781947',
      repo: 'no5-aaron-wu.github.io',
      owner: 'no5-aaron-wu',
      admin: ['no5-aaron-wu'],
      id: '2b21977b526ec34d8ebabc7141186618',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="/js/footer.js"></script><script src="/js/fishes.js"></script><script src="/live2d-widget/autoload.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>